"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
const __1 = require("../../..");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const Settings_util_1 = require("../../../utils/Settings.util");
const Logger_1 = require("../../../logger/Logger");
const sidecar_1 = __importDefault(require("./sidecar"));
const version_1 = require("../../../version");
const SerializerUtil = __importStar(require("../../../utils/Serializer.util"));
class HTTPClient {
    constructor(options) {
        var _a;
        this.options = options;
        this.logger = new Logger_1.Logger("HTTPClient", "HTTPClient", this.options.logger);
        this.isInitialized = false;
        this.clientUrl = `${this.options.daprHost}:${this.options.daprPort}/v1.0`;
        if (!this.clientUrl.startsWith("http://") && !this.clientUrl.startsWith("https://")) {
            this.clientUrl = `http://${this.clientUrl}`;
        }
        if (!HTTPClient.client) {
            HTTPClient.client = node_fetch_1.default;
        }
        // Add a custom agent so we can decide if we want to reuse connections or not
        // we use an agent so we can reuse an open connection, limiting handshake requirements
        // Note: when using an agent, we will encounter TCPWRAP since the connection doesn't get destroyed
        const keepAlive = (_a = this.options.isKeepAlive) !== null && _a !== void 0 ? _a : Settings_util_1.Settings.getDefaultKeepAlive();
        const keepAliveMsecs = 30 * 1000; // it is applicable only when keepAlive is set to true
        if (!HTTPClient.httpAgent) {
            HTTPClient.httpAgent = new http_1.default.Agent({ keepAlive: keepAlive, keepAliveMsecs: keepAliveMsecs });
        }
        if (!HTTPClient.httpsAgent) {
            HTTPClient.httpsAgent = new https_1.default.Agent({ keepAlive: keepAlive, keepAliveMsecs: keepAliveMsecs });
        }
    }
    getClient(requiresInitialization = true) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure the sidecar has been started
            if (requiresInitialization && !this.isInitialized) {
                this.logger.verbose("Client is not initialized, starting sidecar and initializing");
                yield this.start();
            }
            return HTTPClient.client;
        });
    }
    setIsInitialized(isInitialized) {
        this.isInitialized = isInitialized;
    }
    getIsInitialized() {
        return this.isInitialized;
    }
    _startAwaitSidecarStarted() {
        return __awaiter(this, void 0, void 0, function* () {
            yield __1.DaprClient.awaitSidecarStarted(() => __awaiter(this, void 0, void 0, function* () { return yield sidecar_1.default.isStarted(this); }), this.logger);
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            HTTPClient.httpAgent.destroy();
            HTTPClient.httpsAgent.destroy();
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._startAwaitSidecarStarted();
            this.isInitialized = true;
            this.logger.info("Sidecar Started");
            return;
        });
    }
    executeWithApiVersion(apiVersion = "v1.0", url, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const newClientUrl = this.clientUrl.replace("v1.0", apiVersion);
            return yield this.execute(`${newClientUrl}${url}`, params);
        });
    }
    /**
     *
     * @param url The URL to call
     * @param params The parameters to pass to our URL
     * @param requiresInitialization If false, it doesn't require the Dapr sidecar to be started and might fail
     * @returns The result of the call
     */
    execute(url, params, requiresInitialization = true) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const clientOptions = {};
            // Set Method
            clientOptions.method = (params === null || params === void 0 ? void 0 : params.method.toLocaleUpperCase()) || ((params === null || params === void 0 ? void 0 : params.body) ? "POST" : "GET");
            // Set Headers
            clientOptions.headers = (_a = params === null || params === void 0 ? void 0 : params.headers) !== null && _a !== void 0 ? _a : {};
            if (this.options.daprApiToken) {
                clientOptions.headers["dapr-api-token"] = this.options.daprApiToken;
            }
            clientOptions.headers["user-agent"] = `dapr-sdk-js/v${version_1.SDK_VERSION} http/1`;
            // Set Body and Content-Type Header
            if (params === null || params === void 0 ? void 0 : params.body) {
                // If content-type is already present, use that to serialize the data.
                const headerContentType = (_c = (_b = params === null || params === void 0 ? void 0 : params.headers) === null || _b === void 0 ? void 0 : _b["Content-Type"]) !== null && _c !== void 0 ? _c : undefined;
                const { serializedData, contentType } = SerializerUtil.serializeHttp(params === null || params === void 0 ? void 0 : params.body, headerContentType);
                clientOptions.headers["Content-Type"] = contentType;
                clientOptions.body = serializedData;
            }
            const urlFull = url.startsWith("http") ? url : `${this.clientUrl}${url}`;
            const agent = urlFull.startsWith("https") ? HTTPClient.httpsAgent : HTTPClient.httpAgent;
            clientOptions.agent = agent;
            this.logger.debug(`Fetching ${clientOptions.method} ${urlFull} with (headers: ${JSON.stringify(clientOptions.headers)}, body size: ${((_f = (_e = (_d = clientOptions.body) === null || _d === void 0 ? void 0 : _d.toString()) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0) / 1024 / 1024} Mb)`);
            const client = yield this.getClient(requiresInitialization);
            const res = yield client(urlFull, clientOptions);
            // Parse body
            const txt = yield res.text();
            let txtParsed;
            try {
                txtParsed = JSON.parse(txt);
            }
            catch (e) {
                txtParsed = txt;
            }
            // 2XX -> OK; 3XX -> Redirects and Found
            if (res.status >= 200 && res.status <= 399) {
                return txtParsed;
            }
            else {
                throw new Error(JSON.stringify({
                    error: res.statusText,
                    error_msg: txt,
                    status: res.status,
                }));
            }
        });
    }
}
exports.default = HTTPClient;
